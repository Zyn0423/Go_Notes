1s=1000ms
1ms=1000us
1us=1000ns
并行：借助多核CPU运行     #真并行      靠硬件
并发： 1.宏观（用户体验上，程序在并行执行）2.微观（多个计划任务，按顺序执行，在飞快的切换。轮换使用CPU时间轮片）  #假并行   软件

常见的并发技术有哪些
进程并发：1.程序：编译成功后等到的二进制文件。  占用磁盘空间。  死的  1
         2.进程：运行起来的程序。占用系统资源（内存）        活得   N
进程状态：5种
        1.初始态、2.就绪态、3.运行态、4.挂起态（阻塞）、5.结束（停止）态
问题：1.孤儿进程 ： 父进程有义务对子进程进行回收，死亡状态如果是正常状态会有一个返回值，对返回值进行判断，父进程先于子进程结束，则子进程成孤儿进程，子进程的父进程成为init进程，成为init的进程领养孤儿进程
     2.僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸进程


线程并发：
                             进程：最小资源分配单位
       1.什么是线程？LWP轻量级进程  ： 最小执行单位-- CPU分配时间轮片的对象


同步：多个控制流共同操作一个共享资源的情况，都需要同步
       协调步调，先后顺序执行
       线程同步机制：
                   1.互斥锁：建议锁，拿到锁才可以访问，没有拿到锁的的线程要阻塞等待，等待拿锁的线程释放锁
                   2.读写锁：一把锁（读属性，写属性）写独占，读共享。写锁优先级高

每个进程大小4G：可用虚拟地址范围


进程和线程是提高CPU的执行速度
协程：提高执行程序的效率


协程并发：轻量级的线程，轻量级
        Goroutine

总结：
    进程、线程、协程都可以完成并发。
    进程：稳定性强
    线程：节省资源
    协程：效率高



32和64内存地址：2^32=4G     2^64         /1024



Goroutine ：GO程
           创建于进程中 直接使用GO关键字，放置函数调用的前面就会产生一个GO程，默认并发

           特性：主Go程结束，子Go程随之退出

runtime.Gosched()：出让当前GO程所占用CPU轮片时间片，当再次获得CPU时，从出让位置继续恢复执行。
               ----时间片轮转调度算法。
runtime.Goexit():立即终止当前的Goroutine执行，调度器确保所有以注册的defer延迟调用被执行，之后就没有作用
        return:返回当前函数到调用者，return之前的defer都生效

runtime.GOMAXPROCS():用来设置可以并行计算机CPU核数的最大值，并返回之前的值。首次调用的返回值


======================================================================================================
channel:是一种数据类型。对应一个'管道'（IFIO）
channel定义：make(chan,在chan中要传递的数据类型，容量)   容量=0 无缓冲channel  ，有缓冲容量>0
e.g: make(chan,int) or make(chan,string,0)

