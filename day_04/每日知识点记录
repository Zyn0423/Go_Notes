定义channel:make(chan 类型，容量)
          ch:=make(chan string,0)
       写端:ch <- "hello"  写端写数据，读端不在读。阻塞
       读端：str:= <- ch   读端读数据，写端不在写。阻塞


channel 同步数据传递：
        len(chan):剩余未读取的数据个数。cap(chan) 通道的容量



无缓冲channel ：--->同步通信
            通道容量为0，len=0。不能存储数据，channel 应用两个GO程中一个读一个写，具备同步的能力。读写（同步）

有缓冲channel: --->异步通信
            通道容量>0 ,len>0 .channel中剩余未读取的数据个数，cap(ch):通道的容量
            应用于：两个GO程当中
            缓冲区可以进行数据存蓄，储备能力上限，阻塞。具备异步的能力，不需要同时操作channel缓冲区


关闭channel:  无缓冲和有缓冲
            确定不在相对端发送，接收数据。关闭channel,使用close(ch)关闭channel
            对端可以判断channel是否关闭：
                if num,ok:=<-ch;ok == true{
                    如果对端已经关闭，ok-->flase.num 无数据
                    如果对端没有关闭，ok-->true.num保存读取到的数据
                    fmt.println("读")
                }else{
                    fmt.Println("")
                }
            可以使用range替换ok:
                              for num:=range ch{       ch 不能替换为<-ch

                              }
            总结：
                1.数据不发送完，不应该关闭。
                2.已经关闭的channel 不能再向其写数据。保存 panic send on closed channel
                3.写端已经关闭channel,可以从中读取数据，读到0.说明写端已关闭。
                                    读有缓冲channel：如果缓冲区有数据，先读数据，读完数据后，可以继续读，读到0


单项channel:
            默认的chanel是双向的。var ch chan int           ch :=make(chan int)
            单项写chan  var write_ch chan <- int          write_ch :=make(chan<- int)
            单项读chan  var read_ch <-chan int            read_ch :=make(<-chan int)

            转换：
                1. 双向channel可以隐式转换为任意一种单项chan
                        write_ch =ch
                2.单项chan 不能转换为双向chan
                        ch =write_ch/read_ch    error !!!


            传参：传【引用】



阻塞：由于某种原因数据没有到达，当前协程（线程）处于等待状态，直到条件满足，解除阻塞状态。
同步：两个或多个协程（线程）间，保持数据内容一致性的机制。
